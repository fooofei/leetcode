

# 如何引入到单调栈

详细介绍如何从题目理解，引入到单调栈，如何大概率认为单调栈能解决这个题目。

拿序列 [2, 1, 5, 6, 2, 3] 为例，

朴素法，求面积的所有解有

单 个矩形组成的面积 2 1 5 6 2 3  / maxArea = 6

2 个矩形组成的面积 2,1  1,5  5,6  6,2   2,3  / maxArea = 5*2 把 [2, 1] 看成是一个区间，寻找区间内的极小值，面积就是 sectionMin * sectionSize

3 个矩形组成的面积 2,1,5  1,5,6  5,6,2  6,2,3  / maxArea = 2*3

4 个矩形组成的面积 2,1,5,6  1,5,6,2  5,6,2,3  / maxArea = 4*2 

5 个矩形组成的面积 2,1,5,6,2  1,5,6,2,3  / maxArea = 1*5

6 个矩形组成的面积 2,1,5,6,2,3 / maxArea = 1*6

注意到这里有求 **区间内的极值** ，要立马反应到用单调栈走一下，

区间内求极小值，用单调递减（这个递减是错误的，

但是到现在还没有能力分辨出这是个错误，需要继续推演）

计算面积，与序列索引强相关，栈中要保存索引

Stack <[0]2>

Stack <[0]2 [1]1>  // 1 是符合递减，入栈

Stack <[0]2 [1]1> [2]5 这时候要把 1,2 顺序出栈
    1 出栈 计算面积 1
    2 出栈 计算面积 2 / 这时候是没有办法计算 [ 2,1 ] 区间的面积
    我们还得到信息，5 入栈的时候，栈空，说明 5 左边的数字都 < 5

怎么想着，虽然使用了单调递减栈，好像也保存了一个极大值，栈底的是极大值。

那么递减栈不行，试试递增栈。

Stack <[0]2>

Stack <[0]2>   [1]1 
    2 出栈，计算面积 2 
    得到一个信息，象形上， 1 入栈，是因为 1 左边的都 >= 1 ，
    可以想象，1 到达后，把左边大于 1 的都抹平了，跟 1 一样高，
    因为求最大连续矩形，是木桶原理，不看谁高，是看谁低，所以要抹平

Stack <[1]1 [2]5 [3]6>  // 依次入栈

Stack <[1]1 [2]5 [3]6> [4]2
    [3]6 出栈 计算面积 6*1 = 6
    [2]5 出栈 还计算面积 5 吗，(在这里思路要难一下，
        [2]5 的左边是栈中的或者已经出栈的，栈中的都是比它小，出栈的都是 >= [2]5 的，
        比如上面出栈的 [3]6 就是大于 [4]2
        那么计算面积应该带上，
        [2]5 的右边是出栈的，但既然 [2]5 在栈里，说明出栈的都是比 2[5] 高的，也就是
        这里计算面积使用 width = 当前索引 i - 栈顶索引 - 1, 栈空，就用 i - (-1) -1，
        height = 出栈的高 [2]5  area=width*height )
        area = (4-1-1)*5 = 10
        隐含取舍: 既然计算了比 5 还宽的其他面积，就不要计算单个 5 的面积了

Stack <[1]1 [4]2 [5]3>  
数字都遍历完成，但是栈不空，我们还是需要处理栈剩下的，
为了能利用到同样的处理代码，不在 for 循环结束后，单独处理
技巧，末尾入栈 -1 能够推动入栈，-1 是题目中的无效值，不参与最后值的计算


Stack <[1]1 [4]2 [5]3>    [6]-1
    [5]3 出栈 像前面那样计算面积 area=3*(6-4-1)=3
    [4]2 出栈 与上面的方式一样计算面积 area=2*(6-1-1)=8
          宽度包含 [4]2 左边已经出过栈的宽度 和 右边出过栈的宽度
    [1]1 出栈 area = 1*(6-(-1)-1) = 6
        宽度包括左边出过栈的宽度 和 右边出过栈的宽度

计算结束